package main

import (
	"bufio"
	"bytes"
	"compress/gzip"
	"flag"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"time"

	"github.com/platinasystems/weeb"
)

type config struct {
	inFile       string
	outFile      string
	pkgName      string
	urlPath      string
	noCompress   bool
	noInlineData bool
}

type hexWriter struct {
	w      io.Writer
	count  int
	header bool
}

func (h *hexWriter) Write(b []byte) (n int, err error) {
	if !h.header {
		fmt.Fprintf(h.w, "[]byte{\n")
		h.header = true
	}
	for i := range b {
		sep := " "
		h.count++
		if h.count%16 == 0 {
			sep = "\n"
		}
		fmt.Fprintf(h.w, "0x%02x,%s", b[i], sep)
	}
	return len(b), nil
}

func (h *hexWriter) Close() error {
	fmt.Fprintf(h.w, "\n}")
	return nil
}

func main() {
	c := &config{}

	flag.StringVar(&c.outFile, "o", "", "Output file (- for stdout)")
	flag.StringVar(&c.pkgName, "package", "", "Package name for Go output.")
	flag.StringVar(&c.urlPath, "url", "", "URL path to use for content.")
	flag.BoolVar(&c.noCompress, "no-compress", false, "Disable compression.")
	flag.BoolVar(&c.noInlineData, "no-inline-data", false, "Disable inline data; instead create and reference file.")
	flag.Parse()
	if flag.NArg() != 1 {
		fmt.Fprintf(os.Stderr, "Missing file name\n")
		flag.PrintDefaults()
		os.Exit(1)
	}
	c.inFile = flag.Arg(0)

	var err error
	var file *os.File
	file, err = os.Open(c.inFile)
	if err != nil {
		log.Fatal(err)
	}

	w := new(bytes.Buffer)
	fmt.Fprintf(w, "// autogenerated: do not edit!\n")
	fmt.Fprintf(w, "// generated from weebgen %s\n", c.inFile)

	fmt.Fprintf(w, "\n// +build !js\n\n") // don't build for js/gopherjs compile

	name := weeb.GoPackageNameForPath(c.inFile)
	if len(c.pkgName) == 0 {
		c.pkgName = name
	}
	if len(c.urlPath) == 0 {
		c.urlPath = name
	}

	fmt.Fprintf(w, "package %s\n", c.pkgName)

	fmt.Fprintf(w, "import \"github.com/platinasystems/weeb\"\n")
	fmt.Fprintf(w, "func init() {\n")
	fmt.Fprintf(w, "  c := &weeb.Content{\n")
	fmt.Fprintf(w, "    URLPath: \"%s\",\n", c.urlPath)
	now := time.Now()
	fmt.Fprintf(w, "    UnixTimeLastModified: %d, // %s\n", now.Unix(), now.UTC().String())

	ct := "text/plain"
	ext := filepath.Ext(c.inFile)
	switch ext {
	case ".js":
		ct = "text/javascript"
	case ".css":
		ct = "text/css"
	}
	fmt.Fprintf(w, "    ContentType: \"%s\",\n", ct)

	if !c.noCompress {
		fmt.Fprintf(w, "    ContentEncoding: \"%s\",\n", "gzip")
	}

	r := bufio.NewReader(file)

	var iw io.WriteCloser
	var hw io.WriteCloser

	dirFile := c.inFile
	if c.outFile != "-" && c.outFile != "" {
		dirFile = c.outFile
	}
	outDir := filepath.Dir(dirFile)
	outExt := ""
	if !c.noCompress {
		outExt = ".gz"
	}
	outPath := ""
	if c.noInlineData {
		outPath = fmt.Sprintf("%s/%s%s", outDir, name, outExt)
		hw, err = os.Create(outPath)
		if err != nil {
			panic(err)
		}
	} else {
		hw = &hexWriter{w: w}
		iw = hw
	}

	if !c.noCompress {
		iw = gzip.NewWriter(hw)
	}

	if iw != nil {
		if !c.noInlineData {
			fmt.Fprintf(w, "    Data: ")
		} else {
			fmt.Fprintf(w, "    FilePath: \"%s\"", outPath)
		}
		_, err := io.Copy(iw, r)
		if err != nil {
			panic(err)
		}
		iw.Close()
		if iw != hw {
			hw.Close()
		}
		fmt.Fprintf(w, ",\n")
	}

	fmt.Fprintf(w, "}\n") // ends &web.Content{

	fmt.Fprintf(w, "c.Register()\n")
	fmt.Fprintf(w, "}\n")

	// gofmt result
	b := w.Bytes()
	b, err = format.Source(b)
	if err != nil {
		fmt.Printf("%s", w.Bytes())
		panic(err)
	}

	if c.outFile != "-" {
		if c.outFile == "" {
			c.outFile = fmt.Sprintf("%s/%s_weebgen.go", outDir, name)
		}
		err = ioutil.WriteFile(c.outFile, b, 0666)
		if err != nil {
			log.Fatalf("can't write output: %v\n", err)
		}
	} else {
		fmt.Printf("%s", b)
	}
}
